<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>一张图带你读懂Jvm原理 | Hexo</title>
  <meta name="description" content="Jvm知识点将分为如下几个大模块进行分析： 开篇介绍 Java运行时数据区。 什么是垃圾回收？ 常用垃圾回收算法及HotSpot的算法实现。 垃圾收集器。 内存分配与回收策略。此模块也会延展一些内存回收时的坑。 Java内存模型（JMM）。 JVM工具。 头脑风暴（即JVM必备题）。   1、Java虚拟机运行时数据区这里我们先说句题外话，相信大家在面试中经常被问到介绍Java内存模型，我在面试别">
<meta property="og:type" content="article">
<meta property="og:title" content="一张图带你读懂Jvm原理">
<meta property="og:url" content="https://1024chengxuyuan.github.io/2020/07/03/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Jvm知识点将分为如下几个大模块进行分析： 开篇介绍 Java运行时数据区。 什么是垃圾回收？ 常用垃圾回收算法及HotSpot的算法实现。 垃圾收集器。 内存分配与回收策略。此模块也会延展一些内存回收时的坑。 Java内存模型（JMM）。 JVM工具。 头脑风暴（即JVM必备题）。   1、Java虚拟机运行时数据区这里我们先说句题外话，相信大家在面试中经常被问到介绍Java内存模型，我在面试别">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/Jvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/1.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/2.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/3.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/15.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/4.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/14.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/5.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/6.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/7.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/8.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/9.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/10.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/16.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/11.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/12.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/13.png">
<meta property="og:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/17.png">
<meta property="article:published_time" content="2020-07-03T03:37:21.000Z">
<meta property="article:modified_time" content="2022-01-07T06:27:32.000Z">
<meta property="article:author" content="野生程序猿">
<meta property="article:tag" content="Java虚拟机">
<meta property="article:tag" content="Jvm模型">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://1024chengxuyuan.github.io/2020/07/03/3/Jvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://1024chengxuyuan.github.io/2020/07/03/3/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://1024chengxuyuan.github.io" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">野生程序猿</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java Developer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shanghai, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/1024chengxuyuan" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%85%A7%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java內存模型</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Jvm/">Jvm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MicroService/">MicroService</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RabbitMQ/">RabbitMQ</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloudAlibaba/">SpringCloudAlibaba</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/">elasticsearch</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">编程技巧</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/">项目管理工具</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eureka/" rel="tag">Eureka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Feign/" rel="tag">Feign</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gateway/" rel="tag">Gateway</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JMM%E5%85%A7%E5%AD%98%E6%A8%A1%E5%9E%8B/" rel="tag">JMM內存模型</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">Java并发编程</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">Java性能优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%A1%86%E6%9E%B6/" rel="tag">Java框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jvm%E6%A8%A1%E5%9E%8B/" rel="tag">Jvm模型</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MicroService/" rel="tag">MicroService</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nacos/" rel="tag">Nacos</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ribbon/" rel="tag">Ribbon</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Seata/" rel="tag">Seata</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sentinel/" rel="tag">Sentinel</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" rel="tag">项目管理工具</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/Eureka/" style="font-size: 13px;">Eureka</a> <a href="/tags/Feign/" style="font-size: 13px;">Feign</a> <a href="/tags/Gateway/" style="font-size: 13px;">Gateway</a> <a href="/tags/JMM%E5%85%A7%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 13.86px;">JMM內存模型</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 13.29px;">Java基础</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 13.71px;">Java并发编程</a> <a href="/tags/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 13px;">Java性能优化</a> <a href="/tags/Java%E6%A1%86%E6%9E%B6/" style="font-size: 13px;">Java框架</a> <a href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 13.14px;">Java虚拟机</a> <a href="/tags/Jvm%E6%A8%A1%E5%9E%8B/" style="font-size: 13.14px;">Jvm模型</a> <a href="/tags/Kafka/" style="font-size: 13.57px;">Kafka</a> <a href="/tags/MicroService/" style="font-size: 13px;">MicroService</a> <a href="/tags/Nacos/" style="font-size: 13.14px;">Nacos</a> <a href="/tags/Netty/" style="font-size: 13.43px;">Netty</a> <a href="/tags/RabbitMQ/" style="font-size: 14px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Ribbon/" style="font-size: 13px;">Ribbon</a> <a href="/tags/RocketMQ/" style="font-size: 13.57px;">RocketMQ</a> <a href="/tags/Seata/" style="font-size: 13px;">Seata</a> <a href="/tags/Sentinel/" style="font-size: 13.14px;">Sentinel</a> <a href="/tags/SpringBoot/" style="font-size: 13px;">SpringBoot</a> <a href="/tags/elasticsearch/" style="font-size: 13.43px;">elasticsearch</a> <a href="/tags/redis/" style="font-size: 13.14px;">redis</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 13px;">排序算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.43px;">数据结构</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 13.57px;">消息队列</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 13px;">项目管理工具</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">15</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Netty/">Netty</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/17/NettySourceCode/" class="title">Netty04-优化与源码</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-17T02:59:34.000Z" itemprop="datePublished">2023-01-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Netty/">Netty</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/17/NettyAdvanced/" class="title">Netty03-进阶</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-17T02:59:17.000Z" itemprop="datePublished">2023-01-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Netty/">Netty</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/17/NettyEntry/" class="title">Netty02-入门</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-17T02:57:41.000Z" itemprop="datePublished">2023-01-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Netty/">Netty</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/17/Netty01-nio/" class="title">Netty01-nio</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-17T02:53:36.000Z" itemprop="datePublished">2023-01-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/SpringCloudAlibaba/">SpringCloudAlibaba</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/12/SentinelSourceCode/" class="title">Sentinal源码分析</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-12T13:35:16.000Z" itemprop="datePublished">2023-01-12</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-一张图带你读懂Jvm原理" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      一张图带你读懂Jvm原理
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2020/07/03/3/" class="article-date">
	  <time datetime="2020-07-03T03:37:21.000Z" itemprop="datePublished">2020-07-03</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Jvm/">Jvm</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a>, <a class="article-tag-link-link" href="/tags/Jvm%E6%A8%A1%E5%9E%8B/" rel="tag">Jvm模型</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/07/03/3/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="Jvm知识点将分为如下几个大模块进行分析："><a href="#Jvm知识点将分为如下几个大模块进行分析：" class="headerlink" title="Jvm知识点将分为如下几个大模块进行分析："></a>Jvm知识点将分为如下几个大模块进行分析：</h1><ol>
<li>开篇介绍</li>
<li>Java运行时数据区。</li>
<li>什么是垃圾回收？</li>
<li>常用垃圾回收算法及HotSpot的算法实现。</li>
<li>垃圾收集器。</li>
<li>内存分配与回收策略。此模块也会延展一些内存回收时的<strong>坑</strong>。</li>
<li>Java内存模型（JMM）。</li>
<li>JVM工具。</li>
<li>头脑风暴（即JVM必备题）。</li>
</ol>
<p><img src="/2020/07/03/3/Jvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86.png" alt="Jvm知识点梳理"></p>
<h1 id="1、Java虚拟机运行时数据区"><a href="#1、Java虚拟机运行时数据区" class="headerlink" title="1、Java虚拟机运行时数据区"></a>1、Java虚拟机运行时数据区</h1><p>这里我们先说句题外话，相信大家在面试中经常被问到<strong>介绍Java内存模型</strong>，我在面试别人时也会经常问这个问题。但是，往往都会令我比较尴尬，我还话音未落，面试者就会“背诵”一段（Java虚拟机是由堆、方法区、虚拟机栈，吧啦吧啦。。。），估计心里还一脸自豪的想幸好哥提前在网上搜过，早有准备。每每这个时候，我都不忍心打断，因为“背诵”的真的太顺畅了！</p>
<p>这也怪不得面试者，首先Java虚拟机方面的知识，对中高级程序猿来说，工作中正面接触Java虚拟机的东西不多。其次，这个其次咱得好好唠唠，网上搜个Java内存模型，度娘推的第一页大都是介绍Java运行时数据区的，起到了一定的误导作用，大写的尴尬。</p>
<p>本篇将给各位小伙伴先详细介绍Java运行时数据区的组成，Java内存模型也是虚拟机里面的重点，后面会单独抽出一篇来进行介绍。</p>
<h2 id="1-运行时数据区介绍"><a href="#1-运行时数据区介绍" class="headerlink" title="1.运行时数据区介绍"></a>1.运行时数据区介绍</h2><p>程序运行所需的内存空间，有些是不能在编译期就能确定，得要在运行期根据实际运行状况动态地在系统中创建。Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<p><img src="/2020/07/03/3/1.png" alt="Jvm知识点梳理"></p>
<p>如图所示，堆和方法区是所有线程共享的公共区域，堆和方法区所占的内存空间是由JVM负责管理的，在该区域内的内存分配是由HotSpot的内存管理模块维护的，而内存的释放工作则由垃圾收集器自动完成。虚拟机栈、本地方法栈、程序计数器是线程的私有区域，每个线程都关联着唯一的栈和程序计数器，并仅能使用属于自己的那份栈空间和程序计算器来执行程序。</p>
<h2 id="2-堆（Heap）"><a href="#2-堆（Heap）" class="headerlink" title="2.堆（Heap）"></a>2.堆（Heap）</h2><p>对于大多数应用来说，<strong>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块</strong>。堆是可供各个线程<strong>共享</strong>的运行时内存区域，在虚拟机启动的时候就被创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</strong>这一点在Java虚拟机规范中的描述就是：<strong>所有的对象实例以及数组对象都要在堆上分配。</strong>但是随着<strong>JIT编译器</strong>的发展与<strong>逃逸分析</strong>技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p>
<p>Java堆的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<p><strong>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap）</strong>。从内存回收的角度来看，由于现在收集器基本都采用<strong>分代收集算法</strong>，Java虚拟机将堆划分为新生代和老年代。其中，新生代又被分为Eden区，以及两个大小相同的Survivor区（From Survivor，To Survivor）。默认情况下，Java虚拟机采取的是一种动态分配的策略（JVM参数-XX:+UsePSAdaptiveSurvivorSizePolicy），根据生成对象的速率，以及Survivor区的使用情况，动态调整Eden区和Survivor区的比例。也可以通过参数（SurvivorRatio）来调整这个比例，<strong>SurvivorRatio</strong>这个参数就是新生代中Eden区与Survivor区的容量比值，默认是8，代表Eden：Survivor&#x3D;8:1。</p>
<p><img src="/2020/07/03/3/2.png" alt="Jvm知识点梳理"></p>
<h3 id="是否可能有两个对象共用一段内存的事故？"><a href="#是否可能有两个对象共用一段内存的事故？" class="headerlink" title="是否可能有两个对象共用一段内存的事故？"></a>是否可能有两个对象共用一段内存的事故？</h3><p>当调用new指令时，会在Eden区划出一块作为存储对象的内存。由于堆空间是线程共享的，因此直接在这里边划空间是需要进行<strong>同步</strong>的。否则，将有可能出现两个对象共用一段内存的事故。解决方法就是，<strong>Java堆中可能划出多个线程私有的分配缓冲区</strong>TLAB<strong>（Thread Local Allocation Buffer，对应的虚拟机参数-XX：+UseTLAB，默认开启）</strong>。</p>
<p>具体来说，每个线程可以向Java虚拟机申请一段连续内存，比如2048字节，作为<code>线程私有</code>的TLAB。这个操作需要加锁，线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向TLAB中空余内存的起始位置，一个则指向TLAB末尾。接下来的new指令，便可以直接通过指针加法（bump the pointer），也有人叫做指针碰撞来实现，即把指向空余内存位置的指针加上所请求的字节数。如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的TLAB。</p>
<p>JVM默认给每个线程分配一个buffer区域，用来加速对象分配，这个buffer就放在<code>Eden</code>中。对象的分配优化在TLAB上分配，但TLAB通常都不大，遇到对象比较大时，会在Eden区的共享区域进行分配。</p>
<p>这里有一点要特别说明下，虽然上面说TLAB是线程私有的，也只是说在分配这个举动上是线程私有的，在其读取及垃圾回收上都是线程共享的，所以绝大部分情况下在使用上没什么区别。听闻有些“刁钻”一点的面试官在面试很喜欢挖坑问<code>“堆是线程共享的内存区域吗？”</code>其实回答是在很大程度上也没啥毛病，如果非要较真，就略微说下TLAB，因为TLAB是堆内存的一部分，它又是线程私有的，就让“堆是线程共享”这句话显得没有那么准确。</p>
<h2 id="3-方法区（Method-Area）"><a href="#3-方法区（Method-Area）" class="headerlink" title="3.方法区（Method Area）"></a>3.方法区（Method Area）</h2><p>方法区与堆一样是线程共享的，<strong>在虚拟机启动的时候创建</strong>，方法区可视为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p>
<p><strong>方法区类似于传统语言编译后的代码存储区域，它存储每个类的结构信息</strong>，如：</p>
<ul>
<li>常量池</li>
<li>域</li>
<li>方法数据</li>
<li>方法和构造函数的字节码</li>
<li>类、实例、接口初始化时用到的特殊方法</li>
</ul>
<p><strong>备注</strong>：《深入理解Java虚拟机》里将方法区归纳为用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。<strong>这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</strong></p>
<h2 id="4-程序计数器（Program-Counter-Register）"><a href="#4-程序计数器（Program-Counter-Register）" class="headerlink" title="4.程序计数器（Program Counter Register）"></a>4.程序计数器（Program Counter Register）</h2><p>Java虚拟机可以支持多条线程同时执行，每一条Java虚拟机线程都有自己的程序计数器。在任意时刻，一条Java虚拟机线程只会执行一个方法的代码，这个正在被线程执行的方法称为该线程的当前方法（current methon）。如果这个方法不是native的，那程序计数器保存的就是Java虚拟机正在执行的字节码指令的地址。如果该方法是native方法，那程序计数器的值为空（undefined）。程序计数器的容量至少应当保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值。</p>
<p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。<strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p>
<h2 id="5-虚拟机栈（VM-Stack）"><a href="#5-虚拟机栈（VM-Stack）" class="headerlink" title="5.虚拟机栈（VM Stack）"></a>5.虚拟机栈（VM Stack）</h2><p>每一条Java虚拟机线程都有自己私有的Java虚拟机栈，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：<strong>每个方法在执行的同时都会创建一个栈帧（stack frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>。每一个方法从调用直至执行完成的过程，就<strong>对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</strong></p>
<p>Java虚拟机栈可能发生如下异常情况：</p>
<ul>
<li>如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackOverflowError</strong>异常。</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存区创建对应的虚拟机栈，那Java虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</li>
</ul>
<h2 id="6-本地方法栈（Native-Method-Stack）"><a href="#6-本地方法栈（Native-Method-Stack）" class="headerlink" title="6.本地方法栈（Native Method Stack）"></a>6.本地方法栈（Native Method Stack）</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行<strong>Java方法</strong>（也就是字节码）服务，而本地方法栈则为虚拟机使用到的<strong>native方法</strong>服务。</p>
<p>Java虚拟机规范允许本地方法栈实现成固定大小或者根据计算来动态扩展和收缩。如果采用固定大小的本地方法栈，那么每一个线程的本地方法栈容量可以在创建栈的时候独立选定。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h2 id="7-扩展知识点"><a href="#7-扩展知识点" class="headerlink" title="7.扩展知识点"></a>7.扩展知识点</h2><h3 id="7-1-栈上分配和逃逸分析"><a href="#7-1-栈上分配和逃逸分析" class="headerlink" title="7.1 栈上分配和逃逸分析"></a>7.1 栈上分配和逃逸分析</h3><p>在栈中分配的基本思路是这样的：分析局部变量的作用域仅限于方法内部，则JVM直接在栈帧内分配对象空间，避免在堆中分配。这个分析过程称为<strong>逃逸分析（也有叫逸出分析）</strong>，而栈帧内分配对象的方式称为<strong>栈上分配</strong>。</p>
<p>这样做的目的是减少新生代的收集次数，间接提高JVM性能。虚拟机是允许堆逃逸分析开关进行配置的，从Sun Java 6u23以后，HotSpot默认开启逃逸分析。</p>
<h3 id="7-2-栈帧"><a href="#7-2-栈帧" class="headerlink" title="7.2 栈帧"></a>7.2 栈帧</h3><p>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。<strong>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息</strong>。<strong>每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</strong></p>
<p>在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中。因此一个栈帧需要分配多少内存，不会收到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p>
<p>一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。栈帧的概念结构如下：</p>
<p><img src="/2020/07/03/3/3.png" alt="Jvm知识点梳理"></p>
<h2 id="8-Jvm内存参数设置"><a href="#8-Jvm内存参数设置" class="headerlink" title="8.Jvm内存参数设置"></a>8.Jvm内存参数设置</h2><p><img src="/2020/07/03/3/15.png" alt="15"></p>
<p>Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐jar microservice‐eureka‐server.jar  </span><br></pre></td></tr></table></figure>

<h2 id="9-运行时数据区脑图"><a href="#9-运行时数据区脑图" class="headerlink" title="9.运行时数据区脑图"></a>9.运行时数据区脑图</h2><p><img src="/2020/07/03/3/4.png" alt="Jvm知识点梳理"></p>
<h1 id="2、类加载机制以及双亲担保机制"><a href="#2、类加载机制以及双亲担保机制" class="headerlink" title="2、类加载机制以及双亲担保机制"></a>2、类加载机制以及双亲担保机制</h1><h2 id="1、类加载过程"><a href="#1、类加载过程" class="headerlink" title="1、类加载过程"></a><strong>1、类加载过程</strong></h2><p>多个java文件经过编译打包生成可运行jar包，最终由java命令运行某个主类的main函数启动程序，这里首先需要通过<strong>类加载器</strong>把主类加载到JVM。 </p>
<p>主类在运行过程中如果使用到其它类，会逐步加载这些类。 </p>
<p>**注意，jar包里的类不是一次性全部加载的，是使用到时才加载。 **</p>
<p>类加载到使用整个过程有如下几步： </p>
<p><strong>加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt;</strong> 使用 &gt;&gt; 卸载 </p>
<p>加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等 </p>
<p>验证：校验字节码文件的正确性 </p>
<p>准备：给类的静态变量分配内存，并赋予默认值</p>
<p>解析：将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的<strong>静态链接</strong>过程(类加载期间完成)，<strong>动态链接</strong>是在程序运行期间完成的将符号引用替换为直接引用，下节课会讲到动态链接 </p>
<p><strong>初始化</strong>：对类的静态变量初始化为指定的值，执行静态代码块 </p>
<p><img src="/2020/07/03/3/14.png" alt="图片"></p>
<h2 id="2、双亲委派机制"><a href="#2、双亲委派机制" class="headerlink" title="2、双亲委派机制"></a>2、双亲委派机制</h2><p>本知识点单独讲解：<a href="https://1024chengxuyuan.github.io/2020/06/30/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">双亲委派机制与类加载器</a></p>
<h1 id="3、Java虚拟机何谓垃圾及垃圾回收算法"><a href="#3、Java虚拟机何谓垃圾及垃圾回收算法" class="headerlink" title="3、Java虚拟机何谓垃圾及垃圾回收算法"></a>3、Java虚拟机何谓垃圾及垃圾回收算法</h1><p>在Java中内存是由虚拟机自动管理的，虚拟机在内存中划出一片区域，作为满足程序内存分配请求的空间。内存的创建仍然是由程序猿来显示指定的，但是对象的释放却对程序猿是透明的。就是解放了程序猿手动回收内存的工作，交给垃圾回收器来自动回收。</p>
<p>在虚拟机中，释放哪些不再被使用的对象所占空间的过程称为<strong>垃圾收集（Garbage Collection，GC）</strong>。负责垃圾收集的程序模块，成为<strong>垃圾收集器（Garbage Collector）</strong>。</p>
<p><strong>既然虚拟机已经帮我们把垃圾自动处理了，为什么还要去了解GC和内存分配呢？</strong></p>
<blockquote>
<p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对虚拟机的自动管理技术实施必要的监控和调节了。<strong>这也是JVM调优，故障排查，重点需要掌握的知识了。</strong></p>
</blockquote>
<p>本篇我们的重点是介绍何谓垃圾及垃圾回收算法，那我们就要弄清到底什么是垃圾？能不能设计一种强大的垃圾回收算法来解决垃圾回收的所有问题？肯定是没有的，后面介绍的每一种垃圾回收算法都有它得天独厚的优点，也有它避之不及的缺点。针对具体的场景，灵活运用方是上策。</p>
<p>希望大家能带着如下问题进行学习，会收获更大。</p>
<ol>
<li>什么是垃圾？</li>
<li>如何回收垃圾？</li>
<li>有没有一种垃圾回收算法能像银弹一样解决所有垃圾所有？</li>
<li>GC的分类是什么样的？（Minor GC、Major GC、Full GC）</li>
<li>Stop-the-world是什么？</li>
<li>如何避免全堆扫描？</li>
</ol>
<h2 id="1-垃圾回收"><a href="#1-垃圾回收" class="headerlink" title="1 垃圾回收"></a>1 垃圾回收</h2><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在堆进行回收前，第一件事就是要确定这些对象之中哪些还“存活”着，哪些已经“死亡”（即不可能再被任何途径使用的对象）。垃圾回收，其实就是将已经分配出去的，但不再使用的内存回收，以便能够再次分配。在Java虚拟机的规范中，<strong>垃圾指的就是死亡的对象所占据的堆空间</strong>。</p>
<p>那怎么确定一个对象是存活还是死亡呢?</p>
<h3 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a>1.1 引用计数算法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<strong>也就是说，需要截获所有的引用更新操作，并且相应地增减目标对象的计数器</strong>。</p>
<p><strong>题外话</strong>：记得研一那段时间对iOS开发感兴趣，找个公司去实习，现学现搞iOS开发，当时是做了一个模拟炒股的app。用的就是Objective-C，这门语言起初管理内存的方式就是用的这种引用计数算法，不过后面也有了自动管理内存。接触的对象多了，发现很多东西在本质的原理有非常多的相似之处。</p>
<h4 id="引用计数算法缺点："><a href="#引用计数算法缺点：" class="headerlink" title="引用计数算法缺点："></a>引用计数算法缺点：</h4><ul>
<li>需要额外的空间来存储计数器，以及繁琐的更新操作。</li>
<li><strong>无法处理循环引用对象</strong>。</li>
</ul>
<p>其中无法处理循环引用对象，算是引用计数法的一个重大漏洞。</p>
<h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><p>可达性是指，如果一个对象会被至少一个在程序中的变量通过直接或间接的方式被其他可达的对象引用，则称该对象是可达的（reachable）。更准确的说，一个对象只有满足下述两个条件之一，就会被判断为可达的：</p>
<ul>
<li>本身是根对象。根（Root）是指由堆以外空间访问的对象。JVM中会将一组对象标记为根，包括全局变量、部分系统类，以及栈中引用的对象，如当前栈帧中的局部变量和参数。</li>
<li>被一个可达的对象引用。</li>
</ul>
<p>这个算法的<strong>基本思路</strong>就是通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达），则证明此对象是不可用的。</p>
<p><img src="/2020/07/03/3/5.png" alt="Jvm知识点梳理"></p>
<p><strong>GC Roots又是什么呢？可以暂时理解为由堆外指向堆内的引用。</strong></p>
<p>在Java语言中，可以作为<strong>GC Roots的对象</strong>包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
<li>已启动且未停止的Java线程。</li>
</ul>
<p>可达性分析算法可以解决引用计数算法不能解决的循环引用问题。举个例子，即便对象a和b相互引用，只要从GC Roots出发无法到达a或者b，那么可达性分析便不会将它们加入存活对象合集之中。</p>
<p>可达性分析算法本身虽然很简明，但是在实践中还是有不少其他问题需要解决的。比如，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成<strong>误报</strong>（将引用设置为null）或者<strong>漏报</strong>（将引用设置为未被访问过的对象）。误杀还可以接受，Java虚拟机至多损失了部分垃圾回收的机会。<strong>漏报就问题大了，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致Java虚拟机奔溃。</strong></p>
<h3 id="1-3-finalize-方法最终判定对象是否存活"><a href="#1-3-finalize-方法最终判定对象是否存活" class="headerlink" title="1.3 finalize()方法最终判定对象是否存活"></a><strong>1.3 finalize()方法最终判定对象是否存活</strong></h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们 暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。 </p>
<p><strong>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</strong> </p>
<p><strong>1. 第一次标记并进行一次筛选。</strong> </p>
<p>筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有覆盖finalize方法，对象将直接被回收。 </p>
<p><strong>2. 第二次标记</strong> </p>
<p>如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次 机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第 二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本 上它就真的被回收了。 </p>
<p>示例代码： 	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">		List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">			list.add(<span class="keyword">new</span> <span class="title class_">User</span>(i++, UUID.randomUUID().toString())); </span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">User</span>(j‐‐, UUID.randomUUID().toString()); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<h3 id="1-4-判断一个类是无用的类"><a href="#1-4-判断一个类是无用的类" class="headerlink" title="1.4 判断一个类是无用的类"></a><strong>1.4 判断一个类是无用的类</strong></h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ </p>
<p>类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何 实例。</p>
</li>
<li><p>加载该类的 ClassLoader 已经被回收。 </p>
</li>
<li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何 地方通过反射访问该类的方法。</p>
</li>
</ul>
<h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2 垃圾回收算法"></a>2 垃圾回收算法</h2><p>上面我们介绍什么是Java中的垃圾，接下来我们就开始介绍如何高效的回收这些垃圾。</p>
<h3 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a>2.1 标记-清除算法</h3><p>标记-清除（Mark-Sweep）算法可以分为两个阶段：</p>
<ul>
<li>标记阶段：标记出所有可以回收的对象。</li>
<li>清除阶段：回收所有已被标记的对象，释放这部分空间。</li>
</ul>
<p>该算法存在如下不足：</p>
<ol>
<li><strong>内存碎片</strong>。由于Java虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。无法找到足够的连续内存，而不得不提前触发一次垃圾收集动作。</li>
<li><strong>分配效率较低</strong>。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java虚拟机则需要逐个访问列表中的项，来查询能够放入新建对象的空闲内存。</li>
</ol>
<p>标记-清除算法的示意图如下：</p>
<p><img src="/2020/07/03/3/6.png" alt="image-20200704100114775"></p>
<h3 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a>2.2 复制算法</h3><p>复制算法的过程如下：</p>
<ul>
<li>划分区域：将内存区域按比例划分为1个Eden区作为分配对象的“主战场”和2个幸存区（即Survivor空间，划分为2个等比例的from区和to区）。</li>
<li>复制：收集时，打扫“战场”，将Eden区中仍存活的对象复制到某一块幸存区中。</li>
<li>清除：由于上一阶段已确保仍存活的对象已被妥善安置，现在可以“清理战场”了，释放Eden区和另一块幸存区。</li>
<li>晋升：如在“复制”阶段，一块幸存区接纳不了所有的“幸存”对象。则直接晋升到老年代。</li>
</ul>
<p><img src="/2020/07/03/3/7.png" alt="image-20200704100844891"></p>
<p><strong>该算法解决了内存碎片化问题，但堆空间的使用效率极其低下</strong>。在对象存活率较高时，需要进行较多的复制操作，效率会变得很低。</p>
<h3 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记-整理算法"></a>2.3 标记-整理算法</h3><p>该算法分为两个阶段：</p>
<ul>
<li>标记阶段：标记出所有可以回收的对象。</li>
<li>压缩阶段：将标记阶段的对象移动到空间的一端，释放剩余的空间。</li>
</ul>
<p>该算法的标记过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。</p>
<p>标记-整理算法的示意图如下：</p>
<p><img src="/2020/07/03/3/8.png" alt="image-20200704101221766"></p>
<h3 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a>2.4 分代收集算法</h3><p>分代收集算法倒并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<p><img src="/2020/07/03/3/9.png" alt="image-20200704101221766"></p>
<p>在<strong>新生代</strong>中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。而<strong>老年代</strong>中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>标记-清理算法或标记-整理算法</strong>来进行回收。</p>
<h2 id="3-HotSpot算法实现"><a href="#3-HotSpot算法实现" class="headerlink" title="3 HotSpot算法实现"></a>3 HotSpot算法实现</h2><h3 id="3-1-枚举根节点"><a href="#3-1-枚举根节点" class="headerlink" title="3.1 枚举根节点"></a>3.1 枚举根节点</h3><p>以可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中。上面介绍可达性分析算法时有详细介绍GC Roots，可以参看上面。</p>
<h3 id="3-2-安全点（Safepoint）"><a href="#3-2-安全点（Safepoint）" class="headerlink" title="3.2 安全点（Safepoint）"></a>3.2 安全点（Safepoint）</h3><p><strong>安全点，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停</strong>。Safepoint的选定既不能太少以至于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。</p>
<p>安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。只要不离开这个安全点，Java虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。</p>
<p>程序运行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。安全点的选定基本上是以程序“<code>是否具有让程序长时间执行的特征</code>”为标准进行选定的。“<strong>长时间执行</strong>”的最明显特征就是指令序列复用，例如<code>方法调用、循环跳转、异常跳转</code>等，所以具有这些功能的指令才会产生Safepoint。</p>
<p>一般会在以下几个位置选择安全点：</p>
<ol>
<li>循环的末尾</li>
<li>方法临返回前 &#x2F; 调用方法的call指令后</li>
<li>可能抛异常的位置</li>
</ol>
<p>对于安全点，另一个需要考虑的问题就是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。</p>
<p>两种解决方案：</p>
<ul>
<li><p>抢先式中断（Preemptive Suspension）</p>
<p>抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。</p>
</li>
<li><p>主动式中断（Voluntary Suspension）</p>
<p>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志地地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p>
</li>
</ul>
<h3 id="3-3-安全区域"><a href="#3-3-安全区域" class="headerlink" title="3.3 安全区域"></a>3.3 安全区域</h3><p>指在一段代码片段中，引用关系不会发生变化。在这个区域中任意地方开始GC都是安全的。也可以把Safe Region看作是被扩展了的Safepoint。</p>
<h2 id="4-扩展知识"><a href="#4-扩展知识" class="headerlink" title="4 扩展知识"></a>4 扩展知识</h2><h3 id="4-1-GC分类"><a href="#4-1-GC分类" class="headerlink" title="4.1 GC分类"></a>4.1 GC分类</h3><p><strong>Minor GC：</strong></p>
<ul>
<li>针对新生代。</li>
<li>指发生在新生代的垃圾收集动作，因为java对象大多都具备朝生夕死的特性，所以<strong>Minor GC非常频繁</strong>，一般回收速度也比较快。</li>
<li>触发条件：Eden空间满时。</li>
</ul>
<p><strong>Major GC：</strong></p>
<ul>
<li>针对老年代。</li>
<li>指发生在老年代的GC，出现了Major GC，<strong>经常会伴随至少一次的Minor GC</strong>（但非绝对的，在Parallel Scavenge 收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li>
<li>触发条件：Minor GC 会将对象移到老年代中，如果此时老年代空间不够，那么触发 Major GC。</li>
</ul>
<p><strong>Full GC：</strong></p>
<ul>
<li>清理整个堆空间。一定意义上Full GC 可以说是 Minor GC 和 Major GC 的结合。</li>
<li>触发条件：调用System.gc()；老年代空间不足；空间分配担保失败。</li>
</ul>
<h3 id="4-2-Stop-the-world"><a href="#4-2-Stop-the-world" class="headerlink" title="4.2 Stop-the-world"></a>4.2 Stop-the-world</h3><p>GC进行时必须停顿所有Java<strong>执行线程</strong>，这就是<strong>Stop-the-world</strong>。</p>
<p>可达性分析时必须在一个能确保一致性的快照中进行，这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，这一点不满足的话分析结果准确性就无法得到保证。</p>
<p>Stop-the-world是通过安全点机制来实现的。当Java虚拟机接收到Stop-the-world请求，它便会等待所有的线程都到达安全点，才允许请求Stop-the-world的线程进行独占的工作。</p>
<h3 id="4-3-卡表"><a href="#4-3-卡表" class="headerlink" title="4.3 卡表"></a>4.3 卡表</h3><p>有个场景，老年代的对象可能引用新生代的对象，那标记存活对象的时候，需要扫描老年代中的所有对象。因为该对象拥有对新生代对象的引用，那么这个引用也会被称为GC Roots。那不是得又做全堆扫描？成本太高了吧。</p>
<p>HotSpot给出的解决方案是一项叫做<strong>卡表</strong>（Card Table）的技术。该技术将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。</p>
<p>在进行Minor GC的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到Minor GC的GC Roots里。当完成所有脏卡的扫描之后，Java虚拟机便会将所有脏卡的标识位清零。</p>
<p>想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么Java虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。</p>
<p><strong>卡表能用于减少老年代的全堆空间扫描，这能很大的提升GC效率</strong>。</p>
<h1 id="4-垃圾收集器及内存分配策略"><a href="#4-垃圾收集器及内存分配策略" class="headerlink" title="4.垃圾收集器及内存分配策略"></a>4.垃圾收集器及内存分配策略</h1><p>前面介绍了垃圾回收算法，接下来我们介绍垃圾收集器和内存分配的策略。有没有一种牛逼的收集器像银弹一样适配所有场景？很明显，不可能有，不然我也没必要单独搞一篇文章来介绍垃圾收集器了。熟悉不同收集器的优缺点，在实际的场景中灵活运用，才是王道。</p>
<p>在开始介绍垃圾收集器前，我们可以剧透几点：</p>
<ul>
<li>根据不同分代的特点，收集器可能不同。有些收集器可以同时用于新生代和老年代，而有些时候，则需要分别为新生代或老年代选用合适的收集器。一般来说，新生代收集器的收集频率较高，应选用性能高效的收集器；而老年代收集器收集次数相对较少，对空间较为敏感，应当避免选择基于复制算法的收集器。</li>
<li><strong>在垃圾收集执行的时刻，应用程序需要暂停运行</strong>。</li>
<li>可以串行收集，也可以并行收集。</li>
<li>如果能做到并发收集（应用程序不必暂停），那绝对是很妙的事情。</li>
<li>如果收集行为可控，那也是很妙的事情。</li>
<li>默认收集器：<ul>
<li>jdk1.7，1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）</li>
<li>jdk1.9 默认垃圾收集器G1</li>
</ul>
</li>
</ul>
<p>希望大家带着下面的问题进行阅读，有目标的阅读，可能收获更多。</p>
<ol>
<li>为什么没有一种牛逼的收集器像银弹一样适配所有场景？</li>
<li>CMS和G1的对比，你知道他两的区别吗？</li>
<li>为什么CMS只能用作老年代收集器，而不能应用在新生代的收集？</li>
<li>为什么JVM的分代年龄是15？而不是16,20之类的呢？</li>
<li>“动态对象年龄判定”里有个“<strong>天坑</strong>”哦，是啥坑呢？</li>
</ol>
<h2 id="1-垃圾收集器"><a href="#1-垃圾收集器" class="headerlink" title="1 垃圾收集器"></a>1 垃圾收集器</h2><p>GC线程与应用线程保持相对独立，当系统需要执行垃圾回收任务时，先停止工作线程，然后命令GC线程工作。以串行模式工作的收集器，称为<strong>串行收集器（即Serial Collector）</strong>。与之相对的是以并行模式工作的收集器，称为<strong>并行收集器（即Paraller Collector）</strong>。</p>
<h3 id="1-1-串行收集器：Serial"><a href="#1-1-串行收集器：Serial" class="headerlink" title="1.1 串行收集器：Serial"></a>1.1 串行收集器：Serial</h3><p>串行收集器采用单线程方式进行收集，且在GC线程工作时，系统不允许应用线程打扰。此时，<strong>应用程序进入暂停状态</strong>，即Stop-the-world。</p>
<p>Stop-the-world暂停时间的长短，是度量一款收集器性能高低的重要指标。</p>
<p><strong>是针对新生代的垃圾回收器，基于标记-复制算法</strong>。</p>
<h3 id="1-2-并行收集器：ParNew"><a href="#1-2-并行收集器：ParNew" class="headerlink" title="1.2 并行收集器：ParNew"></a>1.2 并行收集器：ParNew</h3><p>并行收集器充分利用了多处理器的优势，采用多个GC线程并行收集。可想而知，多条GC线程执行显然比只使用一条GC线程执行的效率更高。一般来说，与串行收集器相比，在多处理器环境下工作的并行收集器能够极大地缩短Stop-the-world时间。</p>
<p>针对<strong>新生代</strong>的垃圾回收器，<strong>标记-复制算法</strong>，可以看成是Serial的多线程版本</p>
<h3 id="1-3-吞吐量优先收集器：Parallel-Scavenge"><a href="#1-3-吞吐量优先收集器：Parallel-Scavenge" class="headerlink" title="1.3 吞吐量优先收集器：Parallel Scavenge"></a>1.3 吞吐量优先收集器：Parallel Scavenge</h3><p>针对<strong>新生代</strong>的垃圾回收器，<strong>标记-复制算法</strong>，和ParNew类似，但更注重吞吐率。在ParNew的基础上演化而来的Parallel Scanvenge收集器被誉为“吞吐量优先”收集器。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即<strong>吞吐量&#x3D;运行用户代码时间 &#x2F;（运行用户代码时间 + 垃圾收集时间）</strong>。如虚拟机总运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<p>Parallel Scanvenge收集器在ParNew的基础上提供了一组参数，用于配置期望的收集时间或吞吐量，然后以此为目标进行收集。</p>
<p>通过VM选项可以控制吞吐量的大致范围：</p>
<ul>
<li>-XX：MaxGCPauseMills：期望收集时间上限。用来控制收集对应用程序停顿的影响。</li>
<li>-XX：GCTimeRatio：期望的GC时间占总时间的比例，用来控制吞吐量。</li>
<li>-XX：UseAdaptiveSizePolicy：自动分代大小调节策略。</li>
</ul>
<p>但要注意停顿时间与吞吐量这两个目标是相悖的，降低停顿时间的同时也会引起吞吐的降低。因此需要将目标控制在一个合理的范围中。</p>
<p>它与ParNew的主要区别是：</p>
<ul>
<li>Parallel Scavenge：追求CPU吞吐量，能够在较短时间内完成指定任务，适合没有交互的后台计算。弱交互强计算。</li>
<li>ParNew：追求降低用户停顿时间，适合交互式应用。强交互弱计算。</li>
</ul>
<h3 id="1-4-Serial-Old收集器"><a href="#1-4-Serial-Old收集器" class="headerlink" title="1.4 Serial Old收集器"></a>1.4 Serial Old收集器</h3><p>Serial Old是Serial收集器的<strong>老年代</strong>版本，单线程收集器，使用<strong>标记-整理算法</strong>。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。</p>
<h3 id="1-5-Parallel-Old收集器"><a href="#1-5-Parallel-Old收集器" class="headerlink" title="1.5 Parallel Old收集器"></a>1.5 Parallel Old收集器</h3><p>Parallel Old是Parallel Scanvenge收集器的<strong>老年代</strong>版本，<strong>多线程</strong>收集器，使用<strong>标记-整理算法</strong>。</p>
<h3 id="1-6-CMS收集器"><a href="#1-6-CMS收集器" class="headerlink" title="1.6 CMS收集器"></a>1.6 CMS收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器</strong>。</p>
<p>CMS收集器仅作用于<strong>老年代</strong>的收集，是基于<strong>标记-清除算法</strong>的，它的运作过程分为4个步骤：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>其中，初始标记、重新标记这两个步骤仍然需要Stop-the-world。<strong>初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短。</strong></p>
<blockquote>
<p>CMS以流水线方式拆分了收集周期，将耗时长的操作单元保持与应用线程并发执行。只将那些必需STW才能执行的操作单元单独拎出来，控制这些单元在恰当的时机运行，并能保证仅需短暂的时间就可以完成。这样，在整个收集周期内，只有<strong>两次短暂的暂停（初始标记和重新标记）</strong>，<strong>达到了近似并发的目的</strong>。</p>
</blockquote>
<p>CMS收集器<strong>优点</strong>：并发收集、低停顿。</p>
<p>CMS收集器<strong>缺点</strong>：</p>
<ul>
<li>CMS收集器对CPU资源非常敏感。</li>
<li>CMS收集器无法处理浮动垃圾（Floating Garbage）。</li>
<li>CMS收集器是基于标记-清除算法，该算法的缺点都有。</li>
</ul>
<p>CMS收集器之所以能够做到并发，根本原因在于<strong>采用基于“标记-清除”的算法并对算法过程进行了细粒度的分解</strong>。前面篇章介绍过标记-清除算法将产生大量的内存碎片这对新生代来说是难以接受的，因此新生代的收集器并未提供CMS版本。</p>
<h3 id="1-7-G1收集器"><a href="#1-7-G1收集器" class="headerlink" title="1.7 G1收集器"></a>1.7 G1收集器</h3><p>G1重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。</p>
<p>G1与CMS的特征对比如下：</p>
<table>
<thead>
<tr>
<th align="left">特征</th>
<th align="left">G1</th>
<th align="left">CMS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">并发和分代</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">最大化释放堆内存</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">低延时</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">吞吐量</td>
<td align="left">高</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">压实</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">可预测性</td>
<td align="left">强</td>
<td align="left">弱</td>
</tr>
<tr>
<td align="left">新生代和老年代的物理隔离</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
</tbody></table>
<h4 id="G1具备如下特点："><a href="#G1具备如下特点：" class="headerlink" title="G1具备如下特点："></a>G1具备如下特点：</h4><ul>
<li><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过<strong>并发</strong>的方式让Java程序继续运行。</li>
<li>分代收集</li>
<li>空间整合：与CMS的标记-清除算法不同，G1从整体来看是基于<strong>标记-整理算法</strong>实现的收集器，从局部（两个Region之间）上来看是基于“<strong>复制</strong>”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。<strong>这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC</strong>。</li>
<li>可预测的停顿：这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。</li>
</ul>
<p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多相同大小的区域单元，每个单元称为Region。Region是一块地址连续的内存空间，G1模块的组成如下图所示：</p>
<p><img src="/2020/07/03/3/10.png" alt="G1堆的Region布局.png"></p>
<p>G1收集器将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离的了</strong>，它们都是一部分Region（不需要连续）的集合。<strong>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。</p>
<p>对于打算从CMS或者ParallelOld收集器迁移过来的应用，按照<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html">官方</a> 的建议，如果发现符合如下特征，可以考虑更换成G1收集器以追求更佳性能：</p>
<ul>
<li>实时数据占用了超过半数的堆空间；</li>
<li>对象分配率或“晋升”的速度变化明显；</li>
<li>期望消除耗时较长的GC或停顿（超过0.5——1秒）。</li>
</ul>
<blockquote>
<p>原文如下：<br>Applications running today with either the CMS or the ParallelOld garbage collector would benefit switching to G1 if the application has one or more of the following traits.</p>
<ul>
<li>More than 50% of the Java heap is occupied with live data.</li>
<li>The rate of object allocation rate or promotion varies significantly.</li>
<li>Undesired long garbage collection or compaction pauses (longer than 0.5 to 1 second)</li>
</ul>
</blockquote>
<h4 id="G1收集的运作过程大致如下："><a href="#G1收集的运作过程大致如下：" class="headerlink" title="G1收集的运作过程大致如下："></a>G1收集的运作过程大致如下：</h4><ul>
<li><strong>初始标记（Initial Marking）</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，<strong>这阶段需要停顿线程，但耗时很短</strong>。</li>
<li><strong>并发标记（Concurrent Marking）</strong>：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，<strong>这阶段耗时较长</strong>，但可与用户程序并发执行。</li>
<li><strong>最终标记（Final Marking）</strong>：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，<strong>这阶段需要停顿线程，但是可并行执行</strong>。</li>
<li><strong>筛选回收（Live Data Counting and Evacuation）</strong>：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li>
</ul>
<p>我们可以看下官方文档对G1的展望（这段英文描述比较简单，我就不翻译了）：</p>
<blockquote>
<p>Future:<br>G1 is planned as the long term replacement for the Concurrent Mark-Sweep Collector (CMS). Comparing G1 with CMS, there are differences that make G1 a better solution. One difference is that G1 is a compacting collector. G1 compacts sufficiently to completely avoid the use of fine-grained free lists for allocation, and instead relies on regions. This considerably simplifies parts of the collector, and mostly eliminates potential fragmentation issues. Also, G1 offers more predictable garbage collection pauses than the CMS collector, and allows users to specify desired pause targets.</p>
</blockquote>
<h2 id="2-内存分配策略"><a href="#2-内存分配策略" class="headerlink" title="2 内存分配策略"></a>2 内存分配策略</h2><p>对象的内存分配，往大方向上讲，就是在<strong>堆</strong>上分配（但也可能经过JIT编译后被拆散为标量类型并间接地<strong>栈上分配</strong>），<strong>对象主要分配在新生代的Eden区上</strong>，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下可能会直接分配在老年代中。</p>
<h3 id="2-1-对象优先在Eden分配"><a href="#2-1-对象优先在Eden分配" class="headerlink" title="2.1 对象优先在Eden分配"></a>2.1 对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC（前面篇章中有介绍过Minor GC）。但也有一种情况，在<strong>内存担保机制</strong>下，无法安置的对象会直接进到老年代。</p>
<h3 id="2-2-大对象直接进入老年代"><a href="#2-2-大对象直接进入老年代" class="headerlink" title="2.2 大对象直接进入老年代"></a>2.2 大对象直接进入老年代</h3><p>大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</p>
<p><strong>虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配</strong>。目的就是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>
<h3 id="2-3-长期存活的对象将进入老年代"><a href="#2-3-长期存活的对象将进入老年代" class="headerlink" title="2.3 长期存活的对象将进入老年代"></a>2.3 长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1 。对象在Survivor区中每经过一次Minor GC，年龄就加1岁，当年龄达到15岁（默认值），就会被晋升到老年代中。</p>
<blockquote>
<p>对象晋升老年代的年龄阈值，可以通过参数-XX：<strong>MaxTenuringThreshold</strong>设置。</p>
</blockquote>
<h3 id="接下来我们来回答为什么JVM的分代年龄为什么是15？而不是16-20之类的呢？"><a href="#接下来我们来回答为什么JVM的分代年龄为什么是15？而不是16-20之类的呢？" class="headerlink" title="接下来我们来回答为什么JVM的分代年龄为什么是15？而不是16,20之类的呢？"></a>接下来我们来回答为什么JVM的分代年龄为什么是15？而不是16,20之类的呢？</h3><p>真的不是为什么不能是其它数（除了15），着实是臣妾做不到啊！</p>
<p>事情是这样的，HotSpot虚拟机的对象头其中一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“<strong>Mark word</strong>”。</p>
<p>例如，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中25bit用于存储对象哈希码，<strong>4bit用于存储对象分代年龄</strong>，2bit用于存储锁标志位，1bit固定为0 。</p>
<p>明白是什么原因了吗？<strong>对象的分代年龄占4位，也就是0000，最大值为1111也就是最大为15，而不可能为16，20之类的了。</strong></p>
<h3 id="2-4-动态对象年龄判定"><a href="#2-4-动态对象年龄判定" class="headerlink" title="2.4 动态对象年龄判定"></a>2.4 动态对象年龄判定</h3><p>为了能更好的适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代。</p>
<p>满足如下条件之一，对象能晋升老年代：</p>
<ul>
<li>1.对象的年龄达到了MaxTenuringThreshold（默认15）能晋升老年代。</li>
<li>2.如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li>
</ul>
<p>很多文章都只是注意到了上面描述的情况（包括阿里中间件公众号发的一篇文章里也只是这么简单的介绍，当时给它们后台留过言说明情况），但如果只是这么认识的话，会发现在实际的内存回收中有悖于此条规定。</p>
<p>举个小栗子，如对象年龄5的占30%，年龄6的占36%，年龄7的占34%，按那两个标准，对象是不能进入老年代的，<strong>但Survivor都已经100%了啊</strong>？</p>
<p>大家可以关注这个参数<strong>TargetSurvivorRatio，目标存活率，默认为50%<strong>。大致意思就是说年龄从小到大累加，如加入某个年龄段（如栗子中的年龄6）后，总占用超过</strong>Survivor空间*TargetSurvivorRatio</strong>的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即栗子中的年龄6对象，就是年龄6和年龄7晋升到老年代）。<strong>动态对象年龄判断，主要是被TargetSurvivorRatio这个参数来控制。而且算的是年龄从小到大的累加和，而不是某个年龄段对象的大小。</strong></p>
<h3 id="2-5-空间分配担保"><a href="#2-5-空间分配担保" class="headerlink" title="2.5 空间分配担保"></a>2.5 空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看<code>HandlePromotionFailure</code>设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有<strong>风险</strong>的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次<strong>Full GC</strong> 。</p>
<p>上面说的风险是什么呢？我们知道，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</p>
<p><img src="/2020/07/03/3/16.png" alt="G1堆的Region布局.png"></p>
<h3 id="2-6-空间分配担保"><a href="#2-6-空间分配担保" class="headerlink" title="2.6 空间分配担保"></a>2.6 空间分配担保</h3><p>这种情况会把存活的对象部分挪到老年代，部分可能还会放在Survivor区</p>
<h1 id="5-创建对象及对象的访问定位"><a href="#5-创建对象及对象的访问定位" class="headerlink" title="5.创建对象及对象的访问定位"></a>5.创建对象及对象的访问定位</h1><h2 id="1-创建对象"><a href="#1-创建对象" class="headerlink" title="1 创建对象"></a>1 创建对象</h2><p>在Java程序运行过程中无时无刻都有对象被创建出来，<strong>java中对象可以采用new或反射或clone或反序列化的方法创建</strong>。接下来我们我们介绍在虚拟机中，对象（限于普通Java对象，不包括数组和Class对象等）的创建过程。</p>
<p>字节码new表示创建对象，虚拟机遇到该指令时，从栈顶取得目标对象在常量池中的索引，接着定位到目标对象的类型。接下来，虚拟机将根据该类的状态，采取相应的内存分配技术，在内存中分配实例空间，并完成实例数据和对象头的初始化。这样，一个对象就在JVM中创建好了。</p>
<p>实例的创建过程，首先根据从类常量池中获取对象类型信息并验证类是否已被解析过，若确保该类<strong>已被加载和正确解析</strong>，使用<strong>快速分配</strong>（fast allocation）技术为该类分配对象空间；若该类<strong>尚未解析过</strong>，则只能通过<strong>慢速分配</strong>（slow allocation）方式分配实例对象。实例的创建流程如下图所示。</p>
<p><img src="/2020/07/03/3/11.png" alt="G1堆的Region布局.png"></p>
<p>对象创建的基本流程：</p>
<ol>
<li>验证类已被解析。</li>
<li>获取instanceKlass，确保Klass已完全初始化。</li>
<li>若满足快速分配条件，则进入快速分配流程。</li>
<li>若不满足快速分配条件，或者快速分配失败，则进入慢速分配流程。</li>
</ol>
<h3 id="1-1-快速分配"><a href="#1-1-快速分配" class="headerlink" title="1.1 快速分配"></a>1.1 快速分配</h3><p>如果在实例分配之前已经完成了类型的解析，那么分配操作仅仅是在内存空间中划分可用内存，因此能以较高效率实现内存分配，这就是<strong>快速分配</strong>。</p>
<p>根据分配空间是来自于线程私有区域还是共享的堆空间，快速分配可以分为两种空间选择策略。HotSpot通过线程局部分配缓存技术(Thread-Local Allocation Buffers,即TLABs)可以在线程私有区域实现空间的分配。</p>
<blockquote>
<p>可以通过VM选项UseTLAB来开启或关闭TLAB功能。</p>
</blockquote>
<p>根据是否使用TLAB，快速分配方式有两种选择策略：</p>
<ul>
<li><strong>选择TLAB</strong>：首先尝试在TLAB中分配，因为TLAB是线程私有区域，故不需要加锁便能够确保线程安全。在分配一个新的对象空间时，将首先尝试在TLAB空间中分配对象空间，若分配空间的请求失败，则再尝试使用加锁机制在Eden区分配对象。</li>
<li><strong>选择Eden空间</strong>：若失败，则尝试在共享的Eden区进行分配，Eden区是所有线程共享区域，需要保证线程安全，故采用<strong>原子操作</strong>进行分配。若分配失败，则再次尝试该操作，直到分配成功为止。</li>
</ul>
<p>实例空间分配成功以后，将对实例进行初始化。待完成对象的空间分配和初始化后，就可以设置栈顶对象引用。当然，<strong>对象的空间分配和初始化操作都是基于从类常量池中获取对象类型并确保该类已被加载和正确解析的前提下进行的</strong>，如果类未被解析，则需要进行慢速分配。</p>
<h3 id="1-2-慢速分配"><a href="#1-2-慢速分配" class="headerlink" title="1.2 慢速分配"></a>1.2 慢速分配</h3><p>之所以成为慢速分配，<strong>正是因为在分配实例前需要对类进行解析，确保类及依赖类已得到正确的解析和初始化</strong>。慢速分配是调用InterpreterRuntime模块_new()进行的，实现代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保要初始化的类不是抽象类型</span></span><br><span class="line">klass-&gt;check_valid_for_instantiation(<span class="literal">true</span>, CHECK);</span><br><span class="line"><span class="comment">// 确保类已初始化</span></span><br><span class="line">klass-&gt;initialize(CHECK);</span><br><span class="line"><span class="comment">// 分配实例</span></span><br><span class="line"><span class="type">oop</span> <span class="variable">obj</span> <span class="operator">=</span> klass-&gt;allocate_instance(CHECK);</span><br><span class="line"><span class="comment">// 在线程栈中设置对象引用</span></span><br><span class="line">thread-&gt;set_vm_result(obj);</span><br></pre></td></tr></table></figure>

<h3 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h3><p><code>对象分配流程大致如下</code>：首先如果开启栈上分配，JVM会先进行栈上分配，如果没有开启栈上分配或不符合条件则会进行TLAB分配，如果TLAB分配不成功，再尝试在eden区分配，如果对象满足了直接进入老年代的条件，那就直接分配在老年代。在eden区和老年代分配主要通过“指针碰撞”和“空闲列表”两种方式实现，通过CAS解决堆上“非TLAB方式分配”的并发问题。</p>
<h2 id="2-对象的访问定位"><a href="#2-对象的访问定位" class="headerlink" title="2 对象的访问定位"></a>2 对象的访问定位</h2><p>建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作<strong>堆</strong>上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。</p>
<p>目前主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种：</p>
<ul>
<li>如果使用<strong>句柄</strong>访问的话，那么Java堆中将会划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是<strong>对象的句柄地址</strong>，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示。</li>
</ul>
<p><img src="/2020/07/03/3/12.png" alt="G1堆的Region布局.png"></p>
<ul>
<li><p>如果使用<strong>直接指针</strong>访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是<strong>对象地址</strong>。即使用直接指针访问在对象被移动时<strong>reference本身需要被修改</strong>，reference存储的就是对象地址。如下图所示。</p>
<p><img src="/2020/07/03/3/13.png" alt="G1堆的Region布局.png"></p>
</li>
</ul>
<p>这两种对象访问方式各有优势：</p>
<ul>
<li>使用句柄来访问的最大好处就是reference中存储的是<strong>稳定的句柄地址</strong>，在对象被移动（垃圾收集时移动对象时非常普遍的行为）时只会改变句柄中的<strong>实例数据指针</strong>，而reference本身不需要修改。</li>
<li>使用直接指针访问方式的最大好处就是<strong>速度更快，它节省了一次指针定位的时间开销</strong>，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</li>
</ul>
<p>HotSpot就是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p>
<h1 id="6-强引用、软引用、弱引用、虚引用"><a href="#6-强引用、软引用、弱引用、虚引用" class="headerlink" title="6.强引用、软引用、弱引用、虚引用"></a>6.<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用</h1><p>关于强引用、软引用、弱引用、幻象引用的区别，在很多公司的面试题中经常出现，可能有些小伙伴觉得这个知识点比较冷门，其实大家在开发中经常用到，如new一个对象的时候就是强引用的应用。</p>
<p>在java语言中，除了原始数据类型（boolean、byte、short、char、int、float、double、long）的变量，其他所有都是所谓的引用类型，指向各种不同的对象。理解这些引用的区别，对于掌握java对象生命周期和JVM内部相关机制非常有帮助。也有助于更深刻的理解底层对象生命周期、垃圾收集机制等，对设计可靠的缓存框架、诊断应用OOM等问题也大有裨益。</p>
<p>这四种应用主要的区别体现在对象不同的可达性状态和对垃圾收集的影响，他们之间的可达性状态可以参看下图：</p>
<p><img src="/2020/07/03/3/17.png" alt="G1堆的Region布局.png"></p>
<h2 id="1-强引用（strong-reference）"><a href="#1-强引用（strong-reference）" class="headerlink" title="1.强引用（strong reference）"></a>1.强引用（strong reference）</h2><p>强引用就是我们最常见的普通对象引用（如new 一个对象），只要还有强引用指向一个对象，就表明此对象还“活着”。在强引用面前，即使JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），让程序异常终止，也不会靠回收强引用对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就意味着此对象可以被垃圾收集了。但要注意的是，并不是赋值为null后就立马被垃圾回收，具体的回收时机还是要看垃圾收集策略的。</p>
<p>如Object obj &#x3D; new Object();</p>
<h2 id="2-软引用（soft-reference）"><a href="#2-软引用（soft-reference）" class="headerlink" title="2.软引用（soft reference）"></a>2.软引用（soft reference）</h2><p>软引用相对强引用要弱化一些，<strong>可以让对象豁免一些垃圾收集。当内存空间足够的时候，垃圾回收器不会回收它。</strong>只有当JVM认定内存空间不足时才会去回收软引用指向的对象。JVM会确保在抛出OOM前清理软引用指向的对象，而且JVM是很聪明的，会尽可能优先回收长时间闲置不用的软引用指向的对象，对那些刚构建的或刚使用过的软引用指向的对象尽可能的保留。基于软引用的这些特性，<strong>软引用可以用来实现很多内存敏感点的缓存场景</strong>，即如果内存还有空闲，可以暂时缓存一些业务场景所需的数据，当内存不足时就可以清理掉，等后面再需要时，可以重新获取并再次缓存。这样就确保在使用缓存提升性能的同时，不会导致耗尽内存。</p>
<p>软引用通常可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = null;</span><br><span class="line">//有时候会返回null</span><br><span class="line">sf.get();</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以看出sf是对obj的一个软引用，当sf对象还没有被销毁前，sf.get()可以获取到这个对象，如果已被销毁，则返回null。</p>
<p>正确使用软引用的示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;List&lt;Foo&gt;&gt; ref = new SoftReference&lt;List&lt;Foo&gt;&gt;(new LinkedList&lt;Foo&gt;());</span><br><span class="line"></span><br><span class="line">// somewhere else in your code, you create a Foo that you want to add to the list</span><br><span class="line">List&lt;Foo&gt; list = ref.get();</span><br><span class="line">if (list != null)</span><br><span class="line">&#123;</span><br><span class="line">    list.add(foo);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    // list is gone; do whatever is appropriate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用软引用的时候必须检查引用是否为null。因为垃圾收集器可能在任意时刻回收软引用，如果不做是否null的判断，可能会出现NullPointerException的异常。</p>
<p>总的来说，软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行<strong>第二次回收</strong>。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<h2 id="3-弱引用（weak-reference）"><a href="#3-弱引用（weak-reference）" class="headerlink" title="3.弱引用（weak reference）"></a>3.弱引用（weak reference）</h2><p><strong>弱引用指向的对象是一种十分临近finalize状态的情况</strong>，当弱引用被清除的时候，就符合finalize的条件了。弱引用与软引用最大的区别就是弱引用比软引用的生命周期更短暂。垃圾回收器会扫描它所管辖的内存区域的过程中，只要发现弱引用的对象，不管内存空间是否有空闲，都会立刻回收它。如同前面我说过的，具体的回收时机还是要看垃圾回收策略的，因此那些弱引用的对象并不是说只要达到弱引用状态就会立马被回收。</p>
<p>基于弱引用的这些特性，弱引用同样可以应用在很多需要缓存的场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = null;</span><br><span class="line">//有时候会返回null</span><br><span class="line">wf.get();</span><br><span class="line">//返回是否被垃圾回收器标记为即将回收的垃圾</span><br><span class="line">wf.isEnQueued();</span><br></pre></td></tr></table></figure>

<h2 id="4-幻象引用（phantom-reference）"><a href="#4-幻象引用（phantom-reference）" class="headerlink" title="4.幻象引用（phantom reference）"></a>4.幻象引用（phantom reference）</h2><p><strong>幻象引用，也有被说成是虚引用或幽灵引用</strong>。幻象引用并不会决定对象的生命周期。即如果一个对象仅持有虚引用，就相当于没有任何引用一样，在任何时候都可能被垃圾回收器回收。不能通过它访问对象，幻象引用仅仅是提供了一种确保对象被finalize以后，做某些事情的机制（如做所谓的Post-Mortem清理机制），也有人利用幻象引用监控对象的创建和销毁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);</span><br><span class="line">obj=null;</span><br><span class="line">//永远返回null</span><br><span class="line">pf.get();</span><br><span class="line">//返回是否从内存中已经删除</span><br><span class="line">pf.isEnQueued();</span><br></pre></td></tr></table></figure>

<p><code>幻象引用的get方法永远返回null</code>，主要用于检查对象是否已经从内存中删除。</p>
<h2 id="5-生存还是死亡"><a href="#5-生存还是死亡" class="headerlink" title="5.生存还是死亡"></a>5.生存还是死亡</h2><p>通过上面对四种引用类型的分析，你可能发现有些对象即使不可达，但也并非是“非死不可”的，这个时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历<code>两次标记过程</code>：<strong>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法</strong>。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后被一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统奔溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可。譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>
<p>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p><strong>对象的可达性是JVM垃圾收集器决定如何处理对象的一个重要考虑指标</strong>。</p>
<p>所有引用类型都是抽象类java.lang.ref.Reference的子类，子类里提供了get()方法。通过上面的分析中可以得知，<strong>除了幻象引用（因为get永远返回null），如果对象还没有被销毁，都可以通过get方法获取原有对象。</strong>其实有个非常关键的注意点，<code>利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用</code>，也就是人为的改变了对象的可达性状态。所以对于软引用、弱引用之类，垃圾收集器可能会存在<code>二次确认</code>的问题，以确保处于弱引用状态的对象没有改变为强引用。</p>
<p>但是有个问题，如果我们错误的保持了强引用（比如，赋值给了static变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄露。所以，检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄露的一个思路，我们的框架使用到弱引用又怀疑有内存泄露，就可以从这个角度检查。</p>
<p>对于软引用、弱引用、幻象引用可以配合引用队列（ReferenceQueue）来使用，特别是幻象引用，get方法只返回null，如果再不指定引用队列，基本就没有任何意义了。</p>

			
      
    </div>
    <div class="article-footer">
	<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://1024chengxuyuan.github.io/2020/07/03/3/" title="一张图带你读懂Jvm原理" target="_blank" rel="external">https://1024chengxuyuan.github.io/2020/07/03/3/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://1024chengxuyuan.github.io" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://1024chengxuyuan.github.io" target="_blank"><span class="text-dark">野生程序猿</span><small class="ml-1x">Java Developer</small></a></h3>
        <div>一枚野生程序猿。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="lv-container" data-id="city" data-uid="MTAyMC81MDU0Ny8yNzAzMA==">
        <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
      </div>    
    
  </section>


   
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2020/07/03/ArrayList&Vector&LinkedList/" title="ArrayList、Vector和LinkedList的区别"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2020/07/03/sorting/" title="排序算法"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/1024chengxuyuan" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2023 野生程序猿
        
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span>本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
<script defer type="text/javascript">
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];

    if (typeof LivereTower === 'function') { return; }

    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;

    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>








</body>
</html>