<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Timer和TimerTask | Hexo</title>
  <meta name="description" content="转载：http:&#x2F;&#x2F;blog.csdn.net&#x2F;xieyuooo&#x2F;article&#x2F;details&#x2F;8607220 其实就Timer来讲就是一个调度器,而TimerTask呢只是一个实现了run方法的一个类,而具体的TimerTask需要由你自己来实现,例如这样: 123456Timer timer &#x3D; new Timer();timer.schedule(new TimerTask() &amp;#123">
<meta property="og:type" content="article">
<meta property="og:title" content="Timer和TimerTask">
<meta property="og:url" content="https://1024chengxuyuan.github.io/2020/06/21/TimerAndTimerTask/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="转载：http:&#x2F;&#x2F;blog.csdn.net&#x2F;xieyuooo&#x2F;article&#x2F;details&#x2F;8607220 其实就Timer来讲就是一个调度器,而TimerTask呢只是一个实现了run方法的一个类,而具体的TimerTask需要由你自己来实现,例如这样: 123456Timer timer &#x3D; new Timer();timer.schedule(new TimerTask() &amp;#123">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-21T08:17:06.000Z">
<meta property="article:modified_time" content="2022-01-07T06:21:58.000Z">
<meta property="article:author" content="野生程序猿">
<meta property="article:tag" content="JMM內存模型">
<meta property="article:tag" content="Java并发编程">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://1024chengxuyuan.github.io/2020/06/21/TimerAndTimerTask/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://1024chengxuyuan.github.io" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">野生程序猿</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java Developer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shanghai, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/1024chengxuyuan" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%85%A7%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java內存模型</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Jvm/">Jvm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MicroService/">MicroService</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RabbitMQ/">RabbitMQ</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloudAlibaba/">SpringCloudAlibaba</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/elasticsearch/">elasticsearch</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">编程技巧</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/">项目管理工具</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eureka/" rel="tag">Eureka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Feign/" rel="tag">Feign</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gateway/" rel="tag">Gateway</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JMM%E5%85%A7%E5%AD%98%E6%A8%A1%E5%9E%8B/" rel="tag">JMM內存模型</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">Java并发编程</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">Java性能优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E6%A1%86%E6%9E%B6/" rel="tag">Java框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jvm%E6%A8%A1%E5%9E%8B/" rel="tag">Jvm模型</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MicroService/" rel="tag">MicroService</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nacos/" rel="tag">Nacos</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ribbon/" rel="tag">Ribbon</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Seata/" rel="tag">Seata</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sentinel/" rel="tag">Sentinel</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" rel="tag">项目管理工具</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/Eureka/" style="font-size: 13px;">Eureka</a> <a href="/tags/Feign/" style="font-size: 13px;">Feign</a> <a href="/tags/Gateway/" style="font-size: 13px;">Gateway</a> <a href="/tags/JMM%E5%85%A7%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 13.86px;">JMM內存模型</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 13.29px;">Java基础</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 13.71px;">Java并发编程</a> <a href="/tags/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 13px;">Java性能优化</a> <a href="/tags/Java%E6%A1%86%E6%9E%B6/" style="font-size: 13px;">Java框架</a> <a href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 13.14px;">Java虚拟机</a> <a href="/tags/Jvm%E6%A8%A1%E5%9E%8B/" style="font-size: 13.14px;">Jvm模型</a> <a href="/tags/Kafka/" style="font-size: 13.57px;">Kafka</a> <a href="/tags/MicroService/" style="font-size: 13px;">MicroService</a> <a href="/tags/Nacos/" style="font-size: 13.14px;">Nacos</a> <a href="/tags/Netty/" style="font-size: 13.43px;">Netty</a> <a href="/tags/RabbitMQ/" style="font-size: 14px;">RabbitMQ</a> <a href="/tags/Redis/" style="font-size: 13px;">Redis</a> <a href="/tags/Ribbon/" style="font-size: 13px;">Ribbon</a> <a href="/tags/RocketMQ/" style="font-size: 13.57px;">RocketMQ</a> <a href="/tags/Seata/" style="font-size: 13px;">Seata</a> <a href="/tags/Sentinel/" style="font-size: 13.14px;">Sentinel</a> <a href="/tags/SpringBoot/" style="font-size: 13px;">SpringBoot</a> <a href="/tags/elasticsearch/" style="font-size: 13.43px;">elasticsearch</a> <a href="/tags/redis/" style="font-size: 13.14px;">redis</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 13px;">排序算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.43px;">数据结构</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 13.57px;">消息队列</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 13px;">缓存</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 13px;">项目管理工具</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">15</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Netty/">Netty</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/17/NettySourceCode/" class="title">Netty04-优化与源码</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-17T02:59:34.000Z" itemprop="datePublished">2023-01-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Netty/">Netty</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/17/NettyAdvanced/" class="title">Netty03-进阶</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-17T02:59:17.000Z" itemprop="datePublished">2023-01-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Netty/">Netty</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/17/NettyEntry/" class="title">Netty02-入门</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-17T02:57:41.000Z" itemprop="datePublished">2023-01-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Netty/">Netty</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/17/Netty01-nio/" class="title">Netty01-nio</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-17T02:53:36.000Z" itemprop="datePublished">2023-01-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/SpringCloudAlibaba/">SpringCloudAlibaba</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/12/SentinelSourceCode/" class="title">Sentinal源码分析</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-12T13:35:16.000Z" itemprop="datePublished">2023-01-12</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-Timer和TimerTask" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Timer和TimerTask
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2020/06/21/TimerAndTimerTask/" class="article-date">
	  <time datetime="2020-06-21T08:17:06.000Z" itemprop="datePublished">2020-06-21</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/JMM%E5%85%A7%E5%AD%98%E6%A8%A1%E5%9E%8B/" rel="tag">JMM內存模型</a>, <a class="article-tag-link-link" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">Java并发编程</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/06/21/TimerAndTimerTask/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>转载：<a target="_blank" rel="noopener" href="http://blog.csdn.net/xieyuooo/article/details/8607220">http://blog.csdn.net/xieyuooo/article/details/8607220</a></p>
<p>其实就Timer来讲就是一个调度器,而TimerTask呢只是一个实现了run方法的一个类,而具体的TimerTask需要由你自己来实现,例如这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = new Timer();</span><br><span class="line">timer.schedule(new TimerTask() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">      System.out.println(&quot;abc&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 200000 , 1000);</span><br></pre></td></tr></table></figure>

<p>这里直接实现一个TimerTask(当然，你可以实现多个TimerTask，多个TimerTask可以被一个Timer会被分配到多个Timer中被调度，后面会说到Timer的实现机制就是说内部的调度机制)，然后编写run方法，20s后开始执行，每秒执行一次，当然你通过一个timer对象来操作多个timerTask，其实timerTask本身没什么意义，只是和timer集合操作的一个对象，实现它就必然有对应的run方法，以被调用，他甚至于根本不需要实现Runnable，因为这样往往混淆视听了，为什么呢？也是本文要说的重点。</p>
<p>　　在说到timer的原理时，我们先看看Timer里面的一些常见方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void schedule(TimerTask task, long delay)</span><br></pre></td></tr></table></figure>

<p>这个方法是调度一个task，经过delay(ms)后开始进行调度，仅仅调度一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void schedule(TimerTask task, Date time)</span><br></pre></td></tr></table></figure>

<p>在指定的时间点time上调度一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void schedule(TimerTask task,  long delay, long period)</span><br></pre></td></tr></table></figure>

<p> 　这个方法是调度一个task，在delay（ms）后开始调度，每次调度完后，最少等待period（ms）后才开始调度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void schedule(TimerTask task, Date firstTime, long period)</span><br></pre></td></tr></table></figure>

<p>　　和上一个方法类似，唯一的区别就是传入的第二个参数为第一次调度的时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleAtFixedRate(TimerTask task,  long delay,  long period)</span><br></pre></td></tr></table></figure>

<p> 　调度一个task，在delay(ms)后开始调度，然后每经过period(ms)再次调度，<strong>貌似和方法：schedule是一样的，其实不然</strong>，后面你会根据源码看到，schedule在计算下一次执行的时间的时候，是通过当前时间（在任务执行前得到） + 时间片，而<strong>scheduleAtFixedRate</strong>方法是通过当前需要执行的时间（也就是计算出现在应该执行的时间）+ 时间片，前者是运行的实际时间，而后者是理论时间点，例如：<strong>schedule</strong>时间片是5s，那么理论上会在<strong>5、10、15、20</strong>这些时间片被调度，但是如果由于某些CPU征用导致未被调度，假如等到第8s才被第一次调度，那么<strong>schedule</strong>方法计算出来的下一次时间应该是第13s而不是第10s，这样有可能下次就越到20s后而<strong>被少调度一次或多次</strong>，而<strong>scheduleAtFixedRate</strong>方法就是每次理论计算出下一次需要调度的时间用以排序，若第8s被调度，那么计算出应该是第10s，所以它距离当前时间是2s，那么再调度队列排序中，会被优先调度，那么就<strong>尽量减少漏掉调度</strong>的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</span><br></pre></td></tr></table></figure>

<p>方法同上，唯一的区别就是第一次调度时间设置为一个Date时间，而不是当前时间的一个时间片，我们在源码中会详细说明这些内容。</p>
<p>　　接下来看源码</p>
<p>　　首先看Timer的构造方法有几种：</p>
<p>　　构造方法1：无参构造方法，简单通过Tiemer为前缀构造一个线程名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Timer() &#123;    </span><br><span class="line">	this ( &quot;Timer-&quot; + serialNumber()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　创建的线程不为主线程，则主线程结束后，timer自动结束，而无需使用cancel来完成对timer的结束。</p>
<p>　　构造方法2：传入了是否为后台线程，后台线程当且仅当进程结束时，自动注销掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Timer( boolean isDaemon) &#123;    </span><br><span class="line">	this ( &quot;Timer-&quot; + serialNumber(), isDaemon); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　另外两个构造方法负责传入名称和将timer启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Timer(String name,  boolean isDaemon) &#123;     </span><br><span class="line">	thread.setName(name);     </span><br><span class="line">	thread.setDaemon(isDaemon);     </span><br><span class="line">	thread.start(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　这里有一个thread，这个thread很明显是一个线程，被包装在了Timer类中，我们看下这个thread的定义是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private TimerThread thread =  new TimerThread(queue);</span><br></pre></td></tr></table></figure>

<p>　　而定义TimerThread部分的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class TimerThread  extends Thread &#123;</span><br></pre></td></tr></table></figure>

<p> 　看到这里知道了，Timer内部包装了一个线程，用来做独立于外部线程的调度，而TimerThread是一个default类型的，默认情况下是引用不到的，是被Timer自己所使用的。</p>
<p>　　<strong>接下来看下有那些属性</strong></p>
<p>　　除了上面提到的thread，还有一个很重要的属性是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private TaskQueue queue =  new TaskQueue();</span><br></pre></td></tr></table></figure>

<p> 　看名字就知道是一个队列，队列里面可以先猜猜看是什么，那么大概应该是我要调度的任务吧，先记录下了，接下来继续向下看：</p>
<p>里面还有一个属性是：threadReaper，它是Object类型，只是重写了finalize方法而已，是为了垃圾回收的时候，将相应的信息回收掉，做GC的回补，也就是当timer线程由于某种原因死掉了，而未被cancel，里面的队列中的信息需要清空掉，不过我们通常是不会考虑这个方法的，所以知道java写这个方法是干什么的就行了。</p>
<p>　　<strong>接下来看调度方法的实现：</strong></p>
<p>　　对于上面6个调度方法，我们不做一一列举，为什么等下你就知道了：</p>
<p>　　来看下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void schedule(TimerTask task,  long delay)</span><br></pre></td></tr></table></figure>

<p>　　的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void schedule(TimerTask task, long delay) &#123;</span><br><span class="line">    if (delay &lt; 0)</span><br><span class="line">    throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span><br><span class="line">    sched(task, System.currentTimeMillis()+delay, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这里调用了另一个方法，将task传入，第一个参数传入System.currentTimeMillis()+delay可见为第一次需要执行的时间的时间点了（如果传入Date，就是对象.getTime()即可，所以传入Date的几个方法就不用多说了），而第三个参数传入了0，这里可以猜下要么是时间片，要么是次数啥的，不过等会就知道是什么了；另外关于方法：sched的内容我们不着急去看他，先看下重载的方法中是如何做的</p>
<p>　　再看看方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void schedule(TimerTask task,  long delay, long period)</span><br></pre></td></tr></table></figure>

<p>　　源码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void schedule(TimerTask task, long delay, long period) &#123;</span><br><span class="line">    if (delay &lt; 0)</span><br><span class="line">    	throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span><br><span class="line">    if (period &lt;= 0)</span><br><span class="line">    	throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class="line">    sched(task, System.currentTimeMillis()+delay, -period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　看来也调用了方法sched来完成调度，和上面的方法唯一的调度时候的区别是增加了传入的period，而第一个传入的是0，所以确定这个参数为时间片，而不是次数，注意这个里的period加了一个负数，也就是取反，也就是我们开始传入1000，在调用sched的时候会变成-1000，其实最终阅读完源码后你会发现这个算是老外对于一种数字的理解，而并非有什么特殊的意义，所以阅读源码的时候也有这些困难所在。</p>
<p>　　最后再看个方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleAtFixedRate(TimerTasktask, long delay, long period)</span><br></pre></td></tr></table></figure>

<p>　　源码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleAtFixedRate(TimerTask task, long delay, long period) &#123;</span><br><span class="line">    if (delay &lt; 0)</span><br><span class="line">    	throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span><br><span class="line">    if (period &lt;= 0)</span><br><span class="line">    	throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class="line">    sched(task, System.currentTimeMillis()+delay, period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　唯一的区别就是在period没有取反，其实你最终阅读完源码，上面的取反没有什么特殊的意义，老外不想增加一个参数来表示scheduleAtFixedRate，而scheduleAtFixedRate和schedule的大部分逻辑代码一致，因此用了参数的范围来作为区分方法，也就是当你传入的参数不是正数的时候，你调用schedule方法正好是得到scheduleAtFixedRate的功能，而调用scheduleAtFixedRate方法的时候得到的正好是schedule方法的功能，呵呵，这些讨论没什么意义，讨论实质和重点：</p>
<p> 　来看sched方法的实现体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void sched(TimerTask task, long time, long period) &#123;</span><br><span class="line">        if (time &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal execution time.&quot;);</span><br><span class="line"> </span><br><span class="line">        synchronized(queue) &#123;</span><br><span class="line">            if (!thread.newTasksMayBeScheduled)</span><br><span class="line">                throw new IllegalStateException(&quot;Timer already cancelled.&quot;);</span><br><span class="line"> </span><br><span class="line">            synchronized(task.lock) &#123;</span><br><span class="line">                if (task.state != TimerTask.VIRGIN)</span><br><span class="line">                    throw new IllegalStateException(</span><br><span class="line">                        &quot;Task already scheduled or cancelled&quot;);</span><br><span class="line">                task.nextExecutionTime = time;</span><br><span class="line">                task.period = period;</span><br><span class="line">                task.state = TimerTask.SCHEDULED;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            queue.add(task);</span><br><span class="line">            if (queue.getMin() == task)</span><br><span class="line">                queue.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>　　queue为一个队列，我们先不看他数据结构，看到他在做这个操作的时候，发生了同步，所以在timer级别，这个是线程安全的，最后将task相关的参数赋值，主要包含<strong>nextExecutionTime</strong>（下一次执行时间），period（时间片），state（状态），然后将它放入queue队列中，做一次notify操作，为什么要做notify操作呢？看了后面的代码你就知道了。</p>
<p>　　简言之，这里就是讲task放入队列queue的过程，此时，你可能对queue的结构有些兴趣，那么我们先来看看queue属性的结构TaskQueue：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class TaskQueue &#123;    </span><br><span class="line">	private TimerTask[] queue =  new TimerTask[ 128 ];    </span><br><span class="line">	private int size =  0 ;</span><br></pre></td></tr></table></figure>

<p> 　可见，TaskQueue的结构很简单，为一个数组，加一个size，有点像ArrayList，是不是长度就128呢，当然不是，ArrayList可以扩容，它可以，只是会造成内存拷贝而已，所以一个Timer来讲，只要内部的task个数不超过128是不会造成扩容的；内部提供了add(TimerTask)、size()、getMin()、get(int)、removeMin()、quickRemove(int)、rescheduleMin(long newTime)、isEmpty()、clear()、fixUp()、fixDown()、heapify()；</p>
<p>　　这里面的方法大概意思是：</p>
<p>　　**add(TimerTaskt)**为增加一个任务</p>
<p>　　**size()**任务队列的长度</p>
<p>　　**getMin()**获取当前排序后最近需要执行的一个任务，下标为1，队列头部0是不做任何操作的。</p>
<p>　　**get(inti)**获取指定下标的数据，当然包括下标0.</p>
<p>　　**removeMin()**为删除当前最近执行的任务，也就是第一个元素，通常只调度一次的任务，在执行完后，调用此方法，就可以将TimerTask从队列中移除。</p>
<p>　　<strong>quickRmove(inti)<strong>删除指定的元素，一般来说是不会调用这个方法的，这个方法只有在Timer发生purge的时候，并且当对应的</strong>TimerTask</strong>调用了<strong>cancel</strong>方法的时候，才会被调用这个方法，也就是取消某个<strong>TimerTask</strong>，然后就会从队列中移除（注意如果任务在执行中是，还是仍然在执行中的，虽然在队列中被移除了），还有就是这个cancel方法并不是Timer的cancel方法而是TimerTask，一个是调度器的，一个是单个任务的，最后注意，这个quickRmove完成后，是将队列最后一个元素补充到这个位置，所以此时会造成顺序不一致的问题，后面会有方法进行回补。</p>
<p>　　<strong>rescheduleMin</strong>(long newTime)是重新设置当前执行的任务的下一次执行时间，并在队列中将其从新排序到合适的位置，而调用的是后面说的<strong>fixDown</strong>方法。</p>
<p>　　对于<strong>fixUp</strong>和<strong>fixDown</strong>方法来讲，前者是当新增一个task的时候，首先将元素放在队列的尾部，然后向前找是否有比自己还要晚执行的任务，如果有，就将两个任务的顺序进行交换一下。而fixDown正好相反，执行完第一个任务后，需要加上一个时间片得到下一次执行时间，从而需要将其顺序与后面的任务进行对比下。</p>
<p>　　其次可以看下<strong>fixDown</strong>的细节为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void fixDown(int k) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    while ((j = k &lt;&lt; 1) &lt;= size &amp;&amp; j &gt; 0) &#123;</span><br><span class="line">        if (j &lt; size &amp;&amp;</span><br><span class="line">        queue[j].nextExecutionTime &gt; queue[j+1].nextExecutionTime)</span><br><span class="line">        j++; // j indexes smallest kid</span><br><span class="line">        if (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime)</span><br><span class="line">        break;</span><br><span class="line">        TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　这种方式并非排序，而是找到一个合适的位置来交换，因为并不是通过队列逐个找的，而是每次移动一个二进制为，例如传入1的时候，接下来就是2、4、8、16这些位置，找到合适的位置放下即可，顺序未必是完全有序的，它只需要看到距离调度部分的越近的是有序性越强的时候就可以了，这样即可以保证一定的顺序性，达到较好的性能。</p>
<p>　　最后一个方法是<strong>heapify</strong>，其实就是将队列的后半截，全部做一次<strong>fixeDown</strong>的操作，这个操作主要是为了回补<strong>quickRemove</strong>方法，当大量的quickRmove后，顺序被打乱后，此时将一半的区域做一次非常简单的排序即可。</p>
<p>　　这些方法我们不在说源码了，只需要知道它提供了类似于ArrayList的东西来管理，内部有很多排序之类的处理，我们继续回到Timer，里面还有两个方法是：cancel()和方法purge()方法，其实就cancel方法来讲，一个取消操作，在测试中你会发现，如果一旦执行了这个方法timer就会结束掉，看下源码是什么呢：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void cancel() &#123;</span><br><span class="line">    synchronized(queue) &#123;</span><br><span class="line">        thread.newTasksMayBeScheduled = false;</span><br><span class="line">        queue.clear();</span><br><span class="line">        queue.notify();  // In case queue was already empty.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　貌似仅仅将队列清空掉，然后设置了newTasksMayBeScheduled状态为false，最后让队列也调用了下notify操作，但是没有任何地方让线程结束掉，那么就要回到我们开始说的Timer中包含的thread为：TimerThread类了，在看这个类之前，再看下Timer中最后一个purge()类，当你对很多Task做了cancel操作后，此时通过调用purge方法实现对这些cancel掉的类空间的回收，上面已经提到，此时会造成顺序混乱，所以需要调用队里的heapify方法来完成顺序的重排，源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int purge() &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line"></span><br><span class="line">    synchronized(queue) &#123;</span><br><span class="line">        for (int i = queue.size(); i &gt; 0; i--) &#123;</span><br><span class="line">        if (queue.get(i).state == TimerTask.CANCELLED) &#123;</span><br><span class="line">            queue.quickRemove(i);</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    if (result != 0)</span><br><span class="line">    queue.heapify();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　那么调度呢，是如何调度的呢，那些notify，和清空队列是如何做到的呢？我们就要看看TimerThread类了，内部有一个属性是：newTasksMayBeScheduled，也就是我们开始所提及的那个参数在cancel的时候会被设置为false。</p>
<p>　　另一个属性定义了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private TaskQueue queue;</span><br></pre></td></tr></table></figure>

<p> 　也就是我们所调用的queue了，这下联通了吧，不过这里是queue是通过构造方法传入的，传入后赋值用以操作，很明显是Timer传递给这个线程的，我们知道它是一个线程，所以执行的中心自然是run方法了，所以看下run方法的body部分是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;      </span><br><span class="line">	try &#123;        </span><br><span class="line">		mainLoop();      </span><br><span class="line">	&#125;  finally &#123;        </span><br><span class="line">		synchronized (queue) &#123;          </span><br><span class="line">			newTasksMayBeScheduled =  false ;          </span><br><span class="line">			queue.clear();  // Eliminate obsolete references        </span><br><span class="line">		&#125;      </span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　try很简单，就一个mainLoop，看名字知道是主循环程序，finally中也就是必然执行的程序为将参数为为false，并将队列清空掉。</p>
<p>那么最核心的就是mainLoop了，是的，看懂了mainLoop一切都懂了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void mainLoop() &#123;      </span><br><span class="line">	while ( true ) &#123;        </span><br><span class="line">		try &#123;          </span><br><span class="line">			TimerTask task;          </span><br><span class="line">			boolean taskFired;          </span><br><span class="line">			synchronized (queue) &#123;            </span><br><span class="line">				// Wait for queue to become non-empty            </span><br><span class="line">				while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)              													queue.wait();            </span><br><span class="line">				if (queue.isEmpty())              </span><br><span class="line">					break ;  // Queue is empty and will forever remain; die            		</span><br><span class="line">					// Queue nonempty; look at first evt and do the right thing            		</span><br><span class="line">				long currentTime, executionTime;            </span><br><span class="line">				task = queue.getMin();            </span><br><span class="line">				synchronized (task.lock) &#123;              </span><br><span class="line">					if (task.state == TimerTask.CANCELLED) &#123;                														queue.removeMin();                </span><br><span class="line">						continue ;  // No action required, poll queue again              		</span><br><span class="line">					&#125;              </span><br><span class="line">					currentTime = System.currentTimeMillis();              														executionTime = task.nextExecutionTime;              </span><br><span class="line">					if (taskFired = (executionTime&lt;=currentTime)) &#123;                					</span><br><span class="line">						if (task.period ==  0 ) &#123;  // Non-repeating, remove                  											queue.removeMin();                  </span><br><span class="line">							task.state = TimerTask.EXECUTED;                						</span><br><span class="line">						&#125;else &#123;  // Repeating task, reschedule                  						 								queue.rescheduleMin(                   																			task.period&lt; 0 ? currentTime  - task.period : executionTime + task.period); </span><br><span class="line">						&#125;              </span><br><span class="line">                     &#125;            </span><br><span class="line">                  &#125;            </span><br><span class="line">                  if (!taskFired)  // Task hasn&#x27;t yet fired; wait              </span><br><span class="line">                  	queue.wait(executionTime - currentTime);          </span><br><span class="line">               &#125;          </span><br><span class="line">               if (taskFired)  // Task fired; run it, holding no locks                     	</span><br><span class="line">                  task.run();        </span><br><span class="line">               &#125;  catch (InterruptedException e) &#123;        </span><br><span class="line">               &#125;      </span><br><span class="line">            &#125;    </span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<p> 　可以发现这个timer是一个死循环程序，除非遇到不能捕获的异常或break才会跳出，首先注意这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (queue.isEmpty() &amp;&amp;newTasksMayBeScheduled)              </span><br><span class="line">	queue.wait();</span><br></pre></td></tr></table></figure>

<p>　　循环体为循环过程中，条件为queue为空且newTasksMayBeScheduled状态为true，可以看到这个状态其关键作用，也就是跳出循环的条件就是要么队列不为空，要么是newTasksMayBeScheduled状态设置为false才会跳出，而wait就是在等待其他地方对queue发生notify操作，从上面的代码中可以发现，当发生add、cancel以及在threadReaper调用finalize方法的时候会被调用，第三个我们基本可以不考虑其实发生add的时候也就是当队列还是空的时候，发生add使得队列不为空就跳出循环，而cancel是设置了状态，否则不会进入这个循环，那么看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (queue.isEmpty())    </span><br><span class="line">	break ;</span><br></pre></td></tr></table></figure>

<p> 　当跳出上面的循环后，如果是设置了newTasksMayBeScheduled状态为false跳出，也就是调用了cancel，那么queue就是空的，此时就直接跳出外部的死循环，所以cancel就是这样实现的，如果下面的任务还在跑还没运行到这里来，cancel是不起作用的。</p>
<p>　　接下来是获取一个当前系统时间和上次预计的执行时间，如果预计执行的时间小于当前系统时间，那么就需要执行，此时判定时间片是否为0，如果为0，则调用removeMin方法将其移除，否则将task通过rescheduleMin设置最新时间并排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentTime = System.currentTimeMillis(); executionTime = task.nextExecutionTime; </span><br><span class="line">if (taskFired = (executionTime&lt;=currentTime)) &#123;     	</span><br><span class="line">	if (task.period ==  0 ) &#123;  // Non-repeating, remove        				queue.removeMin();        </span><br><span class="line">		task.state = TimerTask.EXECUTED;     </span><br><span class="line">    &#125;  else &#123;  // Repeating task, reschedule        </span><br><span class="line">    	queue.rescheduleMin(        </span><br><span class="line">    	task.period&lt; 0 ? currentTime - task.period : executionTime + task.period);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　这里可以看到，period为负数的时候，就会被认为是按照按照当前系统时间+一个时间片来计算下一次时间，就是前面说的schedule和scheduleAtFixedRate的区别了，其实内部是通过正负数来判定的，也许java是不想增加参数，而又想增加程序的可读性，才这样做，其实通过正负判定是有些诡异的，也就是你如果在schedule方法传入负数达到的功能和scheduleAtFixedRate的功能是一样的，相反在scheduleAtFixedRate方法中传入负数功能和schedule方法是一样的。</p>
<p>　　同时你可以看到period为0，就是只执行一次，所以时间片正负0都用上了，呵呵，然后再看看mainLoop接下来的部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!taskFired) // Taskhasn&#x27;t yet fired; wait    </span><br><span class="line">	queue.wait(executionTime- currentTime);</span><br></pre></td></tr></table></figure>

<p> 　这里是如果任务执行时间还未到，就等待一段时间，当然这个等待很可能会被其他的线程操作add和cancel的时候被唤醒，因为内部有notify方法，所以这个时间并不是完全准确，在这里大多数情况下是考虑Timer内部的task信息是稳定的，cancel方法唤醒的话是另一回事。</p>
<p>　　最后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (taskFired)  // Task fired; run it, holding no locks    </span><br><span class="line">	task.run();</span><br></pre></td></tr></table></figure>

<p> 　如果线程需要执行，那么调用它的run方法，而并非启动一个新的线程或从线程池中获取一个线程来执行，所以TimerTask的run方法并不是多线程的run方法，虽然实现了Runnable，但是仅仅是为了表示它是可执行的，并不代表它必须通过线程的方式来执行的。</p>
<p>　　<strong>回过头来再看看：</strong></p>
<p>　　<strong>Timer</strong>和<strong>TimerTask</strong>的简单组合是多线程的嘛？不是，一个Timer内部包装了“<strong>一个Thread”</strong>和“<strong>一个Task”</strong>队列，这个队列按照一定的方式将任务排队处理，包含的线程在<strong>Timer</strong>的构造方法调用时被启动，这个Thread的run方法无限循环这个Task队列，若队列为空且没发生<strong>cancel</strong>操作，此时会一直等待，如果等待完成后，队列还是为空，则认为发生了cancel从而跳出死循环，结束任务；循环中如果发现任务需要执行的时间小于系统时间，则需要执行，那么根据任务的时间片从新计算下次执行时间，若时间片为0代表只执行一次，则直接移除队列即可。</p>
<p>　　但是是否能实现多线程呢？可以，任何东西是否是多线程完全看个人意愿，多个Timer自然就是多线程的，每个Timer都有自己的线程处理逻辑，当然Timer从这里来看并不是很适合很多任务在短时间内的快速调度，至少不是很适合同一个timer上挂很多任务，在多线程的领域中我们更多是使用多线程中的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Executors.newScheduledThreadPool</span><br></pre></td></tr></table></figure>

<p> 来完成对调度队列中的线程池的处理，内部通过<em><strong>new* ScheduledThreadPoolExecutor</strong>来创建线程池的</em>*Executor**的创建，当然也可以调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Executors.unconfigurableScheduledExecutorService</span><br></pre></td></tr></table></figure>

<p> 　方法来创建一个<strong>DelegatedScheduledExecutorService</strong>其实这个类就是包装了下下<strong>scheduleExecutor</strong>，也就是这只是一个壳，英文理解就是被委派的意思，被托管的意思。</p>

			
      
    </div>
    <div class="article-footer">
	<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://1024chengxuyuan.github.io/2020/06/21/TimerAndTimerTask/" title="Timer和TimerTask" target="_blank" rel="external">https://1024chengxuyuan.github.io/2020/06/21/TimerAndTimerTask/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://1024chengxuyuan.github.io" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://1024chengxuyuan.github.io" target="_blank"><span class="text-dark">野生程序猿</span><small class="ml-1x">Java Developer</small></a></h3>
        <div>一枚野生程序猿。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="lv-container" data-id="city" data-uid="MTAyMC81MDU0Ny8yNzAzMA==">
        <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
      </div>    
    
  </section>


   
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2020/06/23/AQSImplementationPrincipleAndSourceDetails/" title="AQS的实现原理以及源码详解"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2020/06/21/JavaThreadInterviewquestions/" title="Java线程面试题"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/1024chengxuyuan" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2023 野生程序猿
        
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
	{% if theme.mermaid.enable %}
	  <script src='https://unpkg.com/mermaid@{{ theme.mermaid.version }}/dist/mermaid.min.js'></script>
	  <script>
		if (window.mermaid) {
		  mermaid.initialize({theme: 'forest'});
		}
	  </script>
    {% endif %}
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span>本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
<script defer type="text/javascript">
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];

    if (typeof LivereTower === 'function') { return; }

    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;

    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>








</body>
</html>